<?php
/**
 * Classe qui gère les flux de mots clefs
 *
 * @copyright  2016 Samuel Szoniecky
 * @license    "New" BSD License
 * 
 * REFERENCES
 * 
 * THANKS
 */
class Flux_MC extends Flux_Site{
	
	var $kwe = array("autokeyword","zemanta", "alchemy", "opencalais", "yahoo", "textalytics","aylien");
	
	/**
     * Constructeur de la classe
     *
     * @param  string $idBase
     * 
     */
	public function __construct($idBase=false, $bTrace=false)
    {
    		parent::__construct($idBase, $bTrace);    	

    		//on récupère la racine des documents
		if(!$this->dbD)$this->dbD = new Model_DbTable_Flux_Doc($this->db);	    	
		if(!$this->dbM)$this->dbM = new Model_DbTable_Flux_Monade($this->db);	    	
		$this->idDocRoot = $this->dbD->ajouter(array("titre"=>__CLASS__));
		$this->idMonade = $this->dbM->ajouter(array("titre"=>__CLASS__),true,false);
	    	
    }

    /**
     * Fonction pour initialiser les tables de la base de données
     * 
     */
      function initDbTables(){
    		//construction des objets
		if(!$this->dbD)$this->dbD = new Model_DbTable_Flux_Doc($this->db);
		if(!$this->dbE)$this->dbE = new Model_DbTable_Flux_Exi($this->db);
		if(!$this->dbT)$this->dbT = new Model_DbTable_Flux_Tag($this->db);
		if(!$this->dbR)$this->dbR = new Model_DbTable_Flux_Rapport($this->db);
		if(!$this->dbM)$this->dbM = new Model_DbTable_Flux_Monade($this->db);
		if(!$this->dbA)$this->dbA = new Model_DbTable_flux_acti($this->db);
		if(!$this->dbU)$this->dbU = new Model_DbTable_Flux_Uti($this->db);
    	
    }
    
    
     /**
     * Récupère les mots clefs d'une chaine
     *
     * @param string $texte
     * @param string $html
     * @param string $class
     *   
     * @return array
     */
	function get($texte, $html="", $class="autokeyword"){
		
		switch ($class) {
			case "autokeyword":
				if($html!="")$chaine = strip_tags($html);
				else $chaine = $texte;
				$rs = $this->getAutokeyword($chaine);
				break;
			case "alchemy":
				$rs = $this->getAlchemy($texte, $html);
				break;
			case "yahoo":
				$rs = $this->getYahoo($texte, $html);
				break;
			case "zemanta":
				$rs = $this->getZemanta($texte, $html);
				break;
			case "opencalais":
				$rs = $this->getOpencalais($texte, $html);
				break;
			case "textalytics":
				$rs = $this->getTextalytics($texte, $html);
				break;
			case "aylien":
				$rs = $this->getAylien($texte, $html);
				break;
		}
		return $rs;		
	}	
	
    /**
     * Récupère les mots clefs d'une chaine
     *
     * @param string $chaine
     *   
     * @return array
     */
	function getAutokeyword($chaine){
		
		$params['content'] = $chaine; //page content
		//set the length of keywords you like
		$params['min_word_length'] = 4;  //minimum length of single words
		$params['min_word_occur'] = 1;  //minimum occur of single words
		
		$params['min_2words_length'] = 4;  //minimum length of words for 2 word phrases
		$params['min_2words_phrase_length'] = 10; //minimum length of 2 word phrases
		$params['min_2words_phrase_occur'] = 2; //minimum occur of 2 words phrase
		
		$params['min_3words_length'] = 4;  //minimum length of words for 3 word phrases
		$params['min_3words_phrase_length'] = 10; //minimum length of 3 word phrases
		$params['min_3words_phrase_occur'] = 2; //minimum occur of 3 words phrase
		
		$keyword = new autokeyword($params, "UTF-8");
		
		//return $keyword->get_keywords();
		return $keyword->parse_words();
		
	}	
	/**
     * Récupère les mots clefs avec AlchemyAPI
     * http://www.alchemyapi.com
     * @param string $texte
     * @param string $html
     * @param string $format
     * 
     * @return array/xml
     */
	function getAlchemy($texte, $html='', $format = 'json'){

		if($html!="")$chaine=strip_tags($html);
		else $chaine=$texte; 		
		
		// Create an AlchemyAPI object.
		$alchemyObj = new AlchemyAPI();
		$alchemyObj->setAPIKey(KEY_ALCHEMY);
		
		/**TODO: vérifier avec le format html
		
		if($html!=""){
			$body = $alchemyObj->HTMLGetRankedKeywords($html, "", $format);			
		}else{
			$body = $alchemyObj->TextGetRankedKeywords($texte, $format);			
		}
		*/
		
		$body = $alchemyObj->TextGetRankedKeywords($chaine, $format);			
		
		if($format=="json"){
			$result = json_decode($body);
		}else{
			$result = simplexml_load_string($body);
		}
		
		return $result;
		
	}		
	
	/**
     * Récupère les mots clefs avec Zemanta
     * http://developer.zemanta.com/
     * @param string $texte
     * @param string $html
     * @param string $format
     * 
     * @return string
     */
	function getZemanta($texte, $html="", $format = 'json'){
		
		if($html!="")$chaine=$html;
		else $chaine=$texte; 		
				
		/* This are the vars you may need to modify */
		/* Some may be placed in conf files */
		/* Some may be generated by your application */
		$url = 'http://api.zemanta.com/services/rest/0.0/'; //Should be in a conf file
		 // May depend of your application context
		$method="zemanta.suggest";
		//$method="zemanta.suggest_markup";
		
		/* It is easier to deal with arrays */
		$args = array(
		'method'=> $method,
		'api_key'=> KEY_ZEMANTA,
		'text'=> $chaine,
		'format'=> $format,
		'return_rdf_links'=>1
		);
		
		//problème à résoudre marche pas sur mac ???
		$response = $this->getUrlBodyContent($url, $args, false, Zend_Http_Client::POST);		
		
		
		
		if($format=="json"){
			$result = json_decode($response);
		}else{
			$result = simplexml_load_string($response);
		}
		
		
		/* $xml now contains the response body */
		return $result;		
	}	

	/**
     * Récupère les mots clefs avec Yahoo
     * http://developer.yahoo.com/search/content/V2/contentAnalysis.html
     * @param string $text
     * @param string $html
     * @param string $format
     * 
     * @return xml/array
     */
	function getYahoo($texte, $html="", $format='json'){
		
		$url = 'http://query.yahooapis.com/v1/public/yql'; 
		
		/**TODO:vérifier si le traitement est plsu efficace avec une url
		 * 
		 */
		if($html!="")$chaine=strip_tags($html);
		else $chaine=$texte; 		
		
		$characters = array('=', '"', '\\');
		$replacements = array('%3D', '%22', ' ');
		$chaine = str_replace($characters, $replacements, $chaine);
		
		$query = 'SELECT * FROM contentanalysis.analyze WHERE text = "'.$chaine.'"';
		$query = 'SELECT * FROM contentanalysis.analyze WHERE url = "http://sfsic2014.sciencesconf.org/program/details"';
		

		/* It is easier to deal with arrays 
		text	 string (required if url parameter is not used)	 The content to perform analysis (UTF-8 encoded).
		url	 string (required if text parameter is not used)	 The url of t
		related_entities	 boolean: true (default), false	 Whether or not to include related entities/concepts in the response
		show_metadata	 boolean: true (default), false	 Whether or not to include entity/concept metadata in the response
		enable_categorizer	 boolean: true (default), false	 Whether or not to include document category information in the response
		unique	 boolean: true, false (default)	 Whether or not to detect only one occurrence of an entity or a concept that my appear multiple times		
		*/
		$args = array(
		'q'=> $query,
		'format'=> $format
		);
		
		/* Execute the request 
		$client = new Zend_Http_Client($url);
		$client->setParameterPost($args);
		$response = $client->request(Zend_Http_Client::POST);	
		$body = $response->getBody();		
		*/
		$body = $this->getUrlBodyContent($url, $args, false, Zend_Http_Client::POST);		
		
		if($format=="json"){
			$result = json_decode($body);
		}else{
			$result = simplexml_load_string($body);
		}
		
		return $result;
		
		/* message de dépassement du nombre de requête
			cbfunc({
			 "error": {
			  "lang": "en-US",
			  "description": "Query syntax error(s) [line 1:9 missing FROM at 'FROdfM']"
			 }
			});
			<Error xmlns="urn:yahoo:api"  
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
			 xsi:noNamespaceSchemaLocation="http://api.yahoo.com/Api/V1/error.xsd">  
			     The following errors were detected:  
			   <Message>limit exceeded</Message>  
			 </Error> 	
		 */
		
	}
	
	

	/**
     * Récupère les mots clefs avec getKWTextalytics
     * https://textalytics.com/core/topics-info#doc
     * @param string $texte
     * @param string $html
     * 
     * @return array
     */
	function getTextalytics($texte, $html){
		
		if($html!="")$chaine= strip_tags($html);
		else $chaine=$texte; 		
		
		$url = "http://textalytics.com/core/topics-1.2";
				
		$args = array(
			'key'=> KEY_TEXTALYTICS,
			'lang'=> "fr",
			'txt'=>$chaine,
			'tt'=>"a"
		);
		
		/* Execute the request 
		*/
		$body = $this->getUrlBodyContent($url, $args, false, Zend_Http_Client::POST);		
		
		$result = json_decode($body);
		
		return $result;
						
	}

	/**
     * Récupère les mots clefs avec getKWAylien
     * https://textalytics.com/core/topics-info#doc
     * @param string $texte
     * @param string $html
     * @param string $url
     * 
     * @return array
     */
	function getAylien($texte, $html, $url=""){
		
		if($html!="")$chaine= strip_tags($html);
		else $chaine=$texte; 		
		
		$aylien = new Flux_Aylien();
		
		$result = $aylien->getAnalyses($texte, $url, $this->idBase."_".$this->idDoc);
		//$result = $aylien->getAnalyses($texte, $url);
		
		return $result;
						
	}
	
	/**
     * Récupère les mots clefs avec Open calais
     * http://www.opencalais.com/documentation/opencalais-documentation
     * @param string $texte
     * @param string $html
     * 
     * @return array
     */
	function getOpencalais($texte, $html){
		
		if($html!="")$chaine= strip_tags($html);
		else $chaine=$texte; 		
		
		$oc = new OpenCalais(KEY_OPENCALAIS);
		//$oc->outputFormat = "Application/JSON";
				
		$result = $oc->getEntities(substr($chaine, 0, 99000));
		
		return $result;
				
	}
	
	
	/**
     * Récupère les mots clefs avec CEPT
     * https://cept.3scale.net/docs
     * @param string $text
     * @param string $action
    * 
     * @return xml/array
     */
	function getCEPT($texte, $action){
		
		$url = 'http://api.cept.at/v1/'; 
		
		switch ($action) {
			case "similarterms":
				$url .= $action."?term=".$texte; 
				break;
			case "term2bitmap":
				$url .= $action."?term=".$texte; 
				break;
			default:
				;
			break;
		}
		//$url .= "&app_key=".KEY_CEPT."&app_id=".KEY_CEPT_APP_ID;
		
		$args = array(
		'app_key'=> KEY_CEPT,
		'app_id'=> KEY_CEPT_APP_ID
		);
		
		/* Execute the request 
		*/
		$body = $this->getUrlBodyContent($url, $args, false);		
		
		$result = json_decode($body);
		
		return $result;
		
		/* message d'erreur
		    "errorCode": 400,
		    "errorMessage": "at least 'term1' or 'term2' must be specified"
		 */
		
	}

/**
     * Sauvegarde d'un tag
     *
     * @param string/array 	$tag
     * @param integer 		$idRap = identifiant du rapport
     * @param integer 		$poids = poids de la relation
     *   
     * @return integer
     */
	function save($tag, $idRap, $poids){

		//initialise les gestionnaires de base de données
		$this->initDbTables();
		//récupère l'action
		$idAct = $this->dbA->ajouter(array("code"=>__METHOD__));
				
		//on ajoute le tag
		if(is_array($tag))
			$idT = $this->dbT->ajouter($tag);
		else
			$idT = $this->dbT->ajouter(array("code"=>$tag));

		//enregistre le rapport
		$idRapTag = $this->dbR->ajouter(array("monade_id"=>$this->idMonade,"geo_id"=>$this->idGeo
			,"src_id"=>$idRap,"src_obj"=>"rapport"
			,"pre_id"=>$idAct,"pre_obj"=>"acti"
			,"dst_id"=>$idT,"dst_obj"=>"tag"
			,"valeur"=>$poids
			));					
			
		return $idRapTag;
	}
	
    /**
     * enregistre les mots clefs d'une chaine
     *
     * @param int $idDoc
     * @param string $texte
     * @param string $html
     * @param string $class
     *   
     * @return array
     */
	function saveForChaine($idDoc, $texte, $html="", $class="all"){
		
		//initialise les gestionnaires de base de données
		$this->initDbTables();
		//récupère l'action
		$idAct = $this->dbA->ajouter(array("code"=>__METHOD__."_".$class));
		//enregistre le rapport entre le document et l'action
		$idRap = $this->dbR->ajouter(array("monade_id"=>$this->idMonade,"geo_id"=>$this->idGeo
			,"src_id"=>$idDoc,"src_obj"=>"doc"
			,"dst_id"=>$idAct,"dst_obj"=>"acti"
			));
				
		if($class=="all"){
			foreach ($this->kwe as $c) {
				$result[$c] = $this->saveForChaine($idDoc, $texte, $html, $c);
			}
			return $result;
		}else{
			//récupère les mots clefs
			$arrKW = $this->get($texte, $html, $class);			
		}
		

		//récupère la date courante
		$d = new Zend_Date();
				
		//enregistre les mots clefs
	   	if($arrKW){
		   	$i=0;
			switch ($class) {
				case "autokeyword":
					foreach ($arrKW as $kw=>$nb){
						$this->save($kw, $idRap, $nb);
						$i++;	    			
				   	}
					break;
				case "alchemy":
					if($arrKW->status=="OK"){
						foreach ($arrKW->keywords as $kw){
							$idT = $this->saveTag($kw->text, $idDoc, $kw->relevance, $d->get("c"), $idUdst);
							//enregistre le sentiment
							if($kw->sentiment){
								$poids=1;
								if(isset($kw->sentiment->score))$poids=$kw->sentiment->score;
								$this->saveTagTag("", $kw->sentiment->type, $poids, $d->get("c"), $idDoc, $idT, -1, $idUdst);								
							}
							$i++;	    			
					   	}
					}
					break;
				case "yahoo":
					if(isset($arrKW->query->results->yctCategories)){
						foreach ($arrKW->query->results->yctCategories as $kw){
							$idT = $this->saveTag($kw->content, $idDoc, $kw->score, $d->get("c"), $idUdst);
							//enregistre les types
							if(isset($kw->types)){							
								foreach ($kw->types->type as $t){
									if(isset($t->content)){
										$poids=1;
										$this->saveTagTag("", $t->content, $poids, $d->get("c"), $idDoc, $idT, -1, $idUdst);
									}
								}
							}
							/**TODO compléter avec les autres champs de réponse
							 * http://developer.yahoo.com/search/content/V2/contentAnalysis.html
							 */
							$i++;	    			
					   	}
					}
					break;
				case "aylien":
					//problème avec l'extraction des sentiments
					$arrC = $arrKW['concepts']->concepts;
					foreach ($arrC as $url=>$kw){
						//récupère le nom de la ressource
						$pu = parse_url($url);
						//enregistre le document dppedia
						$idDocDBP = $this->dbD->ajouter(array("titre"=>$pu["path"],"tronc"=>"dbpedia","maj"=>$d->get("c"), "type"=>33, "url"=>$url));
						//récupères les formes du concept
						foreach ($kw->surfaceForms as $w){
							$idT = $this->saveTag($w->string, $idDoc, $w->score, $d->get("c"), $idUdst);
						}
						/*récupères les types du concept
						foreach ($kw->types as $w){
							$idT = $this->saveTag($w->string, $idDoc, $w->score, $d->get("c"), $idUdst);
						}
						*/
					}
					$arrC = $arrKW['entities']->entities;
				   	foreach ($arrC as $lbl=>$kw){
						foreach ($kw as $w){
							$this->saveTagTag($lbl, $w, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);							
						}				   			
				   	}
				   	break;
				case "textalytics":
					foreach ($arrKW as $lbl=>$kw){
						foreach ($kw as $w){
							switch ($lbl) {
								case "entity_list":
									$sem = $w->sementity;
									$this->saveTagTag($lbl, $w->form, $w->relevance, $d->get("c"), $idDoc, -1, -1, $idUdst);
									foreach ($w->variant_list as $v) {
										$this->saveTagTag("variant_list", $v->form, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);
										$idDocVar = $this->dbD->ajouter(array("titre"=>$v->form,"parent"=>$idDoc,"maj"=>$d->get("c"), "type"=>39, "url"=>"inip=".$v->inip."&endp=".$v->endp, "note"=>json_encode($v)));										
									}							
									break;								
								case "concept_list":
									$sem = $w->sementity;
									$this->saveTagTag($lbl, $w->form, $w->relevance, $d->get("c"), $idDoc, -1, -1, $idUdst);
									foreach ($w->variant_list as $v) {
										$this->saveTagTag("variant_list", $v->form, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);
										$idDocVar = $this->dbD->ajouter(array("titre"=>$v->form,"parent"=>$idDoc,"maj"=>$d->get("c"), "type"=>39, "url"=>"inip=".$v->inip."&endp=".$v->endp, "note"=>json_encode($v)));										
									}							
									break;								
								case "money_expression_list":
									$this->saveTagTag($lbl, $w->form, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);
									$idDocUri = $this->dbD->ajouter(array("titre"=>$w->type,"parent"=>$idDoc,"maj"=>$d->get("c"), "type"=>39, "url"=>"", "note"=>json_encode($w)));										
									break;								
								case "time_expression_list":
									$this->saveTagTag($lbl, $w->form, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);
									$idDocUri = $this->dbD->ajouter(array("titre"=>$w->form,"parent"=>$idDoc,"maj"=>$d->get("c"), "type"=>39, "url"=>"inip=".$w->inip."&endp=".$w->endp, "note"=>json_encode($w)));										
									break;								
								case "uri_list":
									$idDocUri = $this->dbD->ajouter(array("titre"=>$lbl,"parent"=>$idDoc,"maj"=>$d->get("c"), "type"=>33, "url"=>$w->form, "note"=>json_encode($w)));										
									break;								
								case "relation_list":
									$sem = $w->verb;
									$this->saveTagTag($lbl, $w->form, $w->degree, $d->get("c"), $idDoc, -1, -1, $idUdst);
									$idDocRela = $this->dbD->ajouter(array("titre"=>$w->form,"parent"=>$idDoc,"maj"=>$d->get("c"), "type"=>33, "url"=>"inip=".$w->inip."&endp=".$w->endp, "note"=>json_encode($w)));										
									foreach ($w->complement_list as $v) {
										$this->saveTagTag($v->type, $v->form, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);
									}							
									break;								
							}
						}
				   	}
					break;
				case "opencalais":
					foreach ($arrKW as $lbl=>$kw){
						foreach ($kw as $w){
							$this->saveTagTag($lbl, $w, 1, $d->get("c"), $idDoc, -1, -1, $idUdst);							
						}
				   	}
					break;
				case "zemanta":
					if($arrKW->status=="ok"){
						if(isset($arrKW->keywords)){
							foreach ($arrKW->keywords as $kw){
								$type = $kw->scheme;
								$poids = $kw->confidence;
								//enregistre le tag
								$idT = $this->saveTag($kw->name, $idDoc, $poids, $d->get("c"), $idUdst);
								if($type){
									$this->saveTagTag("", $type, $poids, $d->get("c"), $idDoc, $idT, -1, $idUdst);
								}
						   	}
						}
						if(isset($arrKW->markup->links)){
							foreach ($arrKW->markup->links as $kw){
								$type=false;
								$poids = $kw->relevance;
								foreach ($kw->target as $t){
									//enregistre le tag
									$idT = $this->saveTag($t->title, $idDoc, $poids, $d->get("c"), $idUdst);
									//récupère le document lié
									$idD = $this->dbD->ajouter(array("url"=>$t->url,"titre"=>$t->title,"tronc"=>0,"maj"=>$d->get("c"), "type"=>39));
									//ajoute un lien entre zemanta et le document avec un poids
									$this->dbUD->ajouter(array("uti_id"=>$idUdst, "doc_id"=>$idD, "poids"=>$kw->confidence));										    
									//enregistre le tag pour le document
									$idTLie = $this->saveTag($t->type, $idD, $kw->confidence, $d->get("c"), $idUdst);
									//enregistre les tags liés
									$this->saveTagTag("", "", $poids, $d->get("c"), $idDoc, $idT, $idTLie, $idUdst);
									//enregistre les types
									if(isset($kw->entity_type)){
										if(is_array($kw->entity_type)){
											foreach ($kw->entity_type as $tp) {
												//enregistre les tags liés
												$this->saveTagTag("", $tp, $kw->confidence, $d->get("c"), $idD, $idTLie, -1, $idUdst);
											}											
										}else{
											$this->saveTagTag("", $kw->entity_type, $kw->confidence, $d->get("c"), $idD, $idTLie, -1, $idUdst);
										}
								}
									
								}
								$i++;	    			
						   	}
						}
						/**TODO compléter avec les autres champs de réponse
						 * http://developer.zemanta.com/docs/suggest_markup/
						 */
				   	}
					break;
			}
	   	}
		return $arrKW;		
	}

    /**
     * enregistre les mots clefs d'un utilisateur à partir d'un fichier csv
     *
     * @param string $login
     * @param string $fic
     *   
     * @return array
     */
	function saveForUti($login, $fic){
	    	//
	    	$this->bTrace = true; // pour afficher les traces   	
	    	$this->temps_debut = microtime(true);
		$this->trace("DEBUT ".__METHOD__);

		if(!$this->dbD)$this->dbD = new Model_DbTable_Flux_Doc($this->db);
		if(!$this->dbUD)$this->dbUD = new Model_DbTable_Flux_UtiDoc($this->db);
		
		//récupère les données csv
		$arrKW = $this->csvToArray($fic,0,",");

		//récupère la date courante
		$d = new Zend_Date();
		
		//récupère l'utilisateur
		$idUti = $this->getUser(array("login"=>$login),true);
		
		//enregistre l'extraction de mots clefs
		$idDoc = $this->dbD->ajouter(array("titre"=>"Mots clefs de ".$login,"maj"=>$d->get("c"), "type"=>78, "note"=>json_encode($arrKW)));
		
		foreach ($arrKW as $kw) {
			$this->saveTag($kw[0], $idDoc, 1, $d->get("c"),$idUti);
		}
		
	}
	
    /**
     * enregistre les mots clefs des fichiers d'un répertoire
     *
     * @param string $rep
     *   
     * @return array
     */
	function saveForFicRep($rep){
    	//
    	$this->bTrace = true; // pour afficher les traces   	
    	$this->temps_debut = microtime(true);
		$this->trace("DEBUT ".__METHOD__);
    	//
		
		//initialise les objets
		$pdfParse = new pdfParser();
		$this->dbD = new Model_DbTable_Flux_Doc($this->db);
		
		//récupère les fichiers	
		$globOut = glob($rep);
		foreach ($globOut as $filename) {
			$path_parts = pathinfo($filename);
			switch ($path_parts['extension']) {
				case "pdf":
					//problème avec l'extraction des données du pdf
					$type = 35;
					$pdf = Zend_Pdf::load($filename);
					$contents = false;//$pdfParse->pdf2txt($pdf->render());
					break;
				case "doc":
					$type = 27;
					$docObj = new DocxConversion($filename);
					$contents = $docObj->convertToText();
					break;
			}
			if($contents){
	        		$this->trace($filename);
				//$this->trace($contents);
				//enregistre le document
		        	$idDoc = $this->dbD->ajouter(array("titre"=>$path_parts['filename'],"url"=>$filename, "type"=>$type, "note"=>$contents));
		        	//enregistre les mots clefs
				//var $kwe = array("autokeyword","zemanta", "alchemy", "opencalais", "yahoo", "textalytics","aylien");
		        	$this->saveForChaine($idDoc, $contents,"","all");	        
			}
	    }
		
	}
	
		
	
}