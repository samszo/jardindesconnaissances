<?php
//https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=Cartographic%20Limit%20Rectangle.html
//https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=Clustering.html
//https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=Custom%20DataSource.html
?>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Visualisation des positions sémantiques dans un écosytème de connaissances">
    <title>JDC - Sonar - Jardin</title>
    <script type="text/javascript" src="../js/cesium/Sandcastle-header.js"></script>
    <script type="text/javascript" src="../js/cesium/Cesium.js"></script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';

    var altSurface = 10000000.0;

    //Sandcastle_Begin
    /**
     * This class is an example of a custom DataSource.  It loads JSON data as
     * defined by Google's WebGL Globe, https://github.com/dataarts/webgl-globe.
     * @alias WebGLGlobeDataSource
     * @constructor
     *
     * @param {String} [name] The name of this data source.  If undefined, a name
     *                        will be derived from the url.
     *
     * @example
     * var dataSource = new Cesium.WebGLGlobeDataSource();
     * dataSource.loadUrl('sample.json');
     * viewer.dataSources.add(dataSource);
     */
    function WebGLGlobeDataSource(name) {
        //All public configuration is defined as ES5 properties
        //These are just the "private" variables and their defaults.
        this._name = name;
        this._changed = new Cesium.Event();
        this._error = new Cesium.Event();
        this._isLoading = false;
        this._loading = new Cesium.Event();
        this._entityCollection = new Cesium.EntityCollection();
        this._seriesNames = [];
        this._seriesToDisplay = undefined;
        this._heightScale = 10000000;
        this._entityCluster = new Cesium.EntityCluster();
    }

    Object.defineProperties(WebGLGlobeDataSource.prototype, {
    //The below properties must be implemented by all DataSource instances

    /**
     * Gets a human-readable name for this instance.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {String}
     */
    name : {
        get : function() {
            return this._name;
        }
    },
    /**
     * Since WebGL Globe JSON is not time-dynamic, this property is always undefined.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {DataSourceClock}
     */
    clock : {
        value : undefined,
        writable : false
    },
    /**
     * Gets the collection of Entity instances.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {EntityCollection}
     */
    entities : {
        get : function() {
            return this._entityCollection;
        }
    },
    /**
     * Gets a value indicating if the data source is currently loading data.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Boolean}
     */
    isLoading : {
        get : function() {
            return this._isLoading;
        }
    },
    /**
     * Gets an event that will be raised when the underlying data changes.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Event}
     */
    changedEvent : {
        get : function() {
            return this._changed;
        }
    },
    /**
     * Gets an event that will be raised if an error is encountered during
     * processing.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Event}
     */
    errorEvent : {
        get : function() {
            return this._error;
        }
    },
    /**
     * Gets an event that will be raised when the data source either starts or
     * stops loading.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Event}
     */
    loadingEvent : {
        get : function() {
            return this._loading;
        }
    },

    //These properties are specific to this DataSource.

    /**
     * Gets the array of series names.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {String[]}
     */
    seriesNames : {
        get : function() {
            return this._seriesNames;
        }
    },
    /**
     * Gets or sets the name of the series to display.  WebGL JSON is designed
     * so that only one series is viewed at a time.  Valid values are defined
     * in the seriesNames property.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {String}
     */
    seriesToDisplay : {
        get : function() {
            return this._seriesToDisplay;
        },
        set : function(value) {
            this._seriesToDisplay = value;

            //Iterate over all entities and set their show property
            //to true only if they are part of the current series.
            var collection = this._entityCollection;
            var entities = collection.values;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
                var entity = entities[i];
                entity.show = value === entity.seriesName;
            }
            collection.resumeEvents();
        }
    },
    /**
     * Gets or sets the scale factor applied to the height of each line.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Number}
     */
    heightScale : {
        get : function() {
            return this._heightScale;
        },
        set : function(value) {
            if (value > 0) {
                throw new Cesium.DeveloperError('value must be greater than 0');
            }
            this._heightScale = value;
        }
    },
    /**
     * Gets whether or not this data source should be displayed.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Boolean}
     */
    show : {
        get : function() {
            return this._entityCollection;
        },
        set : function(value) {
            this._entityCollection = value;
        }
    },
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {EntityCluster}
     */
    clustering : {
        get : function() {
            return this._entityCluster;
        },
        set : function(value) {
            if (!Cesium.defined(value)) {
                throw new Cesium.DeveloperError('value must be defined.');
            }
            this._entityCluster = value;
        }
    }
    });

    /**
     * Asynchronously loads the GeoJSON at the provided url, replacing any existing data.
     * @param {Object} url The url to be processed.
     * @returns {Promise} a promise that will resolve when the GeoJSON is loaded.
     */
    WebGLGlobeDataSource.prototype.loadUrl = function(url) {
    if (!Cesium.defined(url)) {
        throw new Cesium.DeveloperError('url is required.');
    }

    //Create a name based on the url
    var name = Cesium.getFilenameFromUri(url);

    //Set the name if it is different than the current name.
    if (this._name !== name) {
        this._name = name;
        this._changed.raiseEvent(this);
    }

    //Use 'when' to load the URL into a json object
    //and then process is with the `load` function.
    var that = this;
    return Cesium.Resource.fetchJson(url).then(function(json) {
        return that.load(json, url);
    }).otherwise(function(error) {
        //Otherwise will catch any errors or exceptions that occur
        //during the promise processing. When this happens,
        //we raise the error event and reject the promise.
        this._setLoading(false);
        that._error.raiseEvent(that, error);
        return Cesium.when.reject(error);
    });
    };

    /**
     * Loads the provided data, replacing any existing data.
     * @param {Array} data The object to be processed.
     */
    WebGLGlobeDataSource.prototype.load = function(allData) {
    //>>includeStart('debug', pragmas.debug);
    if (!Cesium.defined(allData)) {
        throw new Cesium.DeveloperError('data is required.');
    }
    //>>includeEnd('debug');

    //Clear out any data that might already exist.
    this._setLoading(true);
    this._seriesNames.length = 0;
    this._seriesToDisplay = undefined;

    var heightScale = this.heightScale;
    var entities = this._entityCollection;

    //It's a good idea to suspend events when making changes to a
    //large amount of entities.  This will cause events to be batched up
    //into the minimal amount of function calls and all take place at the
    //end of processing (when resumeEvents is called).
    entities.suspendEvents();
    entities.removeAll();

    //WebGL Globe JSON is an array of series, where each series itself is an
    //array of two items, the first containing the series name and the second
    //being an array of repeating latitude, longitude, height values.
    //
    //Here's a more visual example.
    //[["series1",[latitude, longitude, height, ... ]
    // ["series2",[latitude, longitude, height, ... ]]

    // Loop over each series
    var data = allData.result.wdl
    console.log('START data')
    for (var x = 0; x < data.length; x++) {
        var series = data[x];
        var seriesName = series[0];
        var coordinates = series[1];
        //récupère le détail de la série
        var idSerie = seriesName.split(' - ')[0];
        var s = allData.result.series[idSerie].details

        console.log(series)
        //Add the name of the series to our list of possible values.
        this._seriesNames.push(seriesName);

        //Make the first series the visible one by default
        var show = x === 0;
        if (show) {
            this._seriesToDisplay = seriesName;
        }
        //montre toutes les séries
        var show = 1;


        /*ajoute un rectangle avec l'image
        */
        var altCouche = 3;
        var hght = altSurface * altCouche * x;
        var cW = -67.0, cS = 27.0, cE = -63.0, cN = 32.0;
        entities.add({
            rectangle : {
                coordinates : Cesium.Rectangle.fromDegrees(cW, cS, cE, cN),
                height : hght,
                //material : Cesium.Color.fromRandom({alpha : 0.5})
                material: s.thumbnail_url,
            }
        });

        //Now loop over each coordinate in the series and create
        // our entities from the data.
        console.log('START series')
        for (var i = 0; i < coordinates.length; i += 3) {
            var latitude = parseFloat(coordinates[i]);
            var longitude =  parseFloat(coordinates[i + 1]);
            var height =  parseFloat(coordinates[i + 2]);
            console.log(latitude+','+longitude+','+height);

            //Ignore lines of zero height.
            if(height === 0) {
                continue;
            }

            var color = Cesium.Color.fromHsl((0.6 - (height * 0.5)), 1.0, 0.5);
            var surfacePosition = Cesium.Cartesian3.fromDegrees(longitude, latitude, altSurface);
            var heightPosition = Cesium.Cartesian3.fromDegrees(longitude, latitude, height * heightScale);
            heightPosition = Cesium.Cartesian3.fromDegrees(cW, cS, hght);
            

            //WebGL Globe only contains lines, so that's the only graphics we create.
            var polyline = new Cesium.PolylineGraphics();
            polyline.material = new Cesium.ColorMaterialProperty(color);
            polyline.width = new Cesium.ConstantProperty(10);
            polyline.arcType = new Cesium.ConstantProperty(Cesium.ArcType.NONE);
            polyline.positions = new Cesium.ConstantProperty([surfacePosition, heightPosition]);

            //The polyline instance itself needs to be on an entity.
            var entity = new Cesium.Entity({
                id : seriesName + ' index ' + i.toString(),
                show : show,
                polyline : polyline,
                seriesName : seriesName //Custom property to indicate series name
            });

            //Add the entity to the collection.
            entities.add(entity);
        }
        console.log('END series')
    }
    console.log('END data')

    //Once all data is processed, call resumeEvents and raise the changed event.
    entities.resumeEvents();
    this._changed.raiseEvent(this);
    this._setLoading(false);
    };

    WebGLGlobeDataSource.prototype._setLoading = function(isLoading) {
    if (this._isLoading !== isLoading) {
        this._isLoading = isLoading;
        this._loading.raiseEvent(this, isLoading);
    }
    };

    //Now that we've defined our own DataSource, we can use it to load
    //any JSON data formatted for WebGL Globe.
    var dataSource = new WebGLGlobeDataSource();
    //var urlData = '../data/cesium/population909500.json';
    var urlData = 'https://jardindesconnaissances.univ-paris8.fr/jdc/public/sonar/flux?q=getEvalsWebGLGlobe';
    //var urlData = '../sonar/flux?q=getEvalsWebGLGlobe';
    dataSource.loadUrl(urlData).then(function() {

        //After the initial load, create buttons to let the user switch among series.
        function createSeriesSetter(seriesName) {
            return function() {
                dataSource.seriesToDisplay = seriesName;
            };
        }
        for (var i = 0; i < dataSource.seriesNames.length; i++) {
            var seriesName = dataSource.seriesNames[i];
            //Sandcastle.addToolbarButton(seriesName, createSeriesSetter(seriesName));
        }
    });
    
    //Create a Viewer instances and add the DataSource.
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiYTI3OWI2My03MDNlLTQyZjAtYWY5OS02ZTU5MGY2MjFkMjUiLCJpZCI6MTQ2MjAsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1NjU5NDU1MzR9.zuJWBeovOnevAVL2LCjrLN8vN3zswKTuPVdRh28hWmc';
    var viewer = new Cesium.Viewer('cesiumContainer', {
        animation : false
        ,timeline : false
        //,terrainProvider:false        
    });
    viewer.clock.shouldAnimate = false;
    viewer.dataSources.add(dataSource);


    // Tropics of Cancer and Capricorn
    //var coffeeBeltRectangle = Cesium.Rectangle.fromDegrees(-180.0, -23.43687, 180.0, 23.43687);
    // hemisphère nord
    //var coffeeBeltRectangle = Cesium.Rectangle.fromDegrees(-180.0, 0, 180, 90);
    // hemisphère sud
    //var coffeeBeltRectangle = Cesium.Rectangle.fromDegrees(-180.0, -90, 180, 0);
    //viewer.scene.globe.cartographicLimitRectangle = coffeeBeltRectangle;

    viewer.scene.skyAtmosphere.show = true;


    //var promise = Cesium.GeoJsonDataSource.load('../data/ne_110m_admin_0_countries.geojson');
    var promise = Cesium.GeoJsonDataSource.load('../data/europe.geojson');
    
    promise.then(function(dataGeo) {
        viewer.dataSources.add(dataGeo);

        //Get the array of entities
        var entities = dataGeo.entities.values;

        var colorHash = {};
        for (var i = 0; i < entities.length; i++) {
            //For each entity, create a random color based on the state name.
            //Some states have multiple entities, so we store the color in a
            //hash so that we use the same color for the entire state.
            var entity = entities[i];
            var name = entity.name;
            /*
            var color = colorHash[name];
            if (!color) {
                color = Cesium.Color.fromRandom({
                    alpha : 0.8
                });
                colorHash[name] = color;
            }
            */
            var color = colorHash[name] = Cesium.Color.fromRandom({
                        red : 1.0,
                        green : 1.0,
                        blue : 1.0,
                        alpha : 0.6
                    });
            //Set the polygon material to our random color.
            entity.polygon.material = color;
            //Remove the outlines.
            entity.polygon.outline = false;

            //Extrude the polygon based on the state's population.  Each entity
            //stores the properties for the GeoJSON feature it was created from
            //Since the population is a huge number, we divide by 50.
            //entity.polygon.extrudedHeight = 30000000;
            entity.polygon.height = altSurface;
        }
    }).otherwise(function(error){
        //Display any errrors encountered while loading.
        window.alert(error);
    });    

    //var posiCenter = getMapCenter(viewer);
    var nbConcept=6, lng = 2.3613169, lat=48.9449133//P8
    ,angleSlice=Math.PI * 2 / nbConcept, posi = Cesium.Cartesian3.fromDegrees(lng,lat, 0)
    ,posiPoly = [], altCrible = altSurface/4, radius = 6;
    for (let index = 0; index < nbConcept; index++) {
        let ln = lng + (radius * Math.cos(angleSlice*index - Math.PI/2)); 
        //let ln = (radius * Math.cos(angleSlice*index - Math.PI/2)); 
        posiPoly.push(ln);
        let la = lat + (radius * Math.sin(angleSlice*index - Math.PI/2)); 
        //let la = (radius * Math.sin(angleSlice*index - Math.PI/2)); 
        posiPoly.push(la);        
        posiPoly.push(altCrible);        
    }
    var cribleP = viewer.entities.add({
        name : 'Crible polygon',
        polygon : {
            hierarchy : Cesium.Cartesian3.fromDegreesArrayHeights(posiPoly),
            //extrudedHeight: 0,
        perPositionHeight : true,
        material : Cesium.Color.ORANGE.withAlpha(0.5),
        outline : true,
        outlineColor : Cesium.Color.BLACK,
        arcType : Cesium.ArcType.GEODESIC
            
            }
    });
    var opo = (3*nbConcept)/(nbConcept/2);
    var radius = 100000*Cesium.Cartesian3.distance(
        new Cesium.Cartesian3(posiPoly[0], posiPoly[1], posiPoly[2])
        , new Cesium.Cartesian3(posiPoly[opo], posiPoly[opo+1], posiPoly[opo+2])
        );
    var cribleE = viewer.entities.add({
        name : 'Crible ellipsoid',
        position: posi,
        ellipsoid : {
            radii : new Cesium.Cartesian3(radius, radius, radius),
            fill : false,
            outline : true,
            outlineColor : Cesium.Color.YELLOW,
            slicePartitions : nbConcept,
            stackPartitions : nbConcept
        }
    });
    /*
    var cribleC = viewer.entities.add({
            position: posi,
            cylinder : {
                length :altCrible,
                topRadius : altCrible,
                bottomRadius : 10.0,
                material : Cesium.Color.fromRandom({alpha : 0.3}),
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
            }
        });    

    var blueStar = viewer.entities.add({
        name : 'Blue star with mitered corners and outline',
        polylineVolume : {
            positions : Cesium.Cartesian3.fromDegreesArrayHeights([lng, lat, 0.0,
                                                                lng+10, lat+10, altCrible/4,
                                                                lng+20, lat+20, altCrible/3,
                                                                lng+30, lat+30, altCrible/2,
                                                                lng, lat, altCrible
                                                            ]),
            //shape : computeStar(nbConcept, 70000, 50000),
            shape : computePoly(nbConcept, 100000),
            //cornerType : Cesium.CornerType.MITERED,
            material : Cesium.Color.BLUE
        }
    });
    */
    //construction des lignes d'axes
    for (let i = 0; i < nbConcept; i++) {
        var posiAxes = [];
        //ajoute un ligne du centre 
        posiAxes.push(lng);
        posiAxes.push(lat);
        posiAxes.push(altCrible);
        //vers le point du concept
        let idx = 3*i;
        posiAxes.push(posiPoly[idx]);
        posiAxes.push(posiPoly[idx+1]);
        posiAxes.push(posiPoly[idx+2]);

        var orangeOutlined = viewer.entities.add({
        name : 'Axe '+i,
        polyline : {
            positions : Cesium.Cartesian3.fromDegreesArrayHeights(posiAxes),
            width : 12,
            /*
            material : new Cesium.PolylineOutlineMaterialProperty({
                color : Cesium.Color.ORANGE,
                outlineWidth : 3,
                outlineColor : Cesium.Color.BLACK
            })
            */
            arcType : Cesium.ArcType.GEODESIC,
            material : new Cesium.PolylineArrowMaterialProperty(Cesium.Color.PURPLE)
        }
    });

    }


    //Cesium.Ellipsoid.UNIT_SPHERE

    //Sandcastle_End
    Sandcastle.finishedLoading();

}

if (typeof Cesium !== 'undefined') {
    startup(Cesium);
} else if (typeof require === 'function') {
    require(['Cesium'], startup);
}

function getMapCenter(viewer) {            
        var windowPosition = new Cesium.Cartesian2(viewer.container.clientWidth / 2, viewer.container.clientHeight / 2);
        var pickRay = viewer.scene.camera.getPickRay(windowPosition);
        var pickPosition = viewer.scene.globe.pick(pickRay, viewer.scene);
        var pickPositionCartographic = viewer.scene.globe.ellipsoid.cartesianToCartographic(pickPosition);
        //console.log(pickPositionCartographic.longitude * (180/Math.PI));
        //console.log(pickPositionCartographic.latitude * (180/Math.PI));
        return pickPositionCartographic;
}

function computeStar(arms, rOuter, rInner) {
    var angle = Math.PI / arms;
    var length = 2 * arms;
    var positions = new Array(length);
    for (var i = 0; i < length; i++) {
        var r = (i % 2) === 0 ? rOuter : rInner;
        positions[i] = new Cesium.Cartesian2(Math.cos(i * angle) * r, Math.sin(i * angle) * r);
    }
    return positions;
}

function computePoly(nbConcept, r) {
    let angleSlice=Math.PI * 2 / nbConcept,positions = [];
    for (let index = 0; index < nbConcept; index++) {
        let ln = r * Math.cos(angleSlice*index - Math.PI/2); 
        let la = r * Math.sin(angleSlice*index - Math.PI/2); 
        positions.push(new Cesium.Cartesian2(ln, la));
    }
    return positions;
}

</script>
</body>
</html>

